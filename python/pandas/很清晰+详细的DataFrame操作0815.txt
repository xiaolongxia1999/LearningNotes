https://www.cnblogs.com/xiaoxuebiye/p/7223774.html
为防止丢失，复制到下面：




整理pandas操作


本文原创，转载请标识出处： http://www.cnblogs.com/xiaoxuebiye/p/7223774.html

导入数据：

复制代码
pd.read_csv(filename)：从CSV文件导入数据
pd.read_table(filename)：从限定分隔符的文本文件导入数据
pd.read_excel(filename)：从Excel文件导入数据
pd.read_sql(query, connection_object)：从SQL表/库导入数据
pd.read_json(json_string)：从JSON格式的字符串导入数据
pd.read_html(url)：解析URL、字符串或者HTML文件，抽取其中的tables表格
pd.read_clipboard()：从你的粘贴板获取内容，并传给read_table()
pd.DataFrame(dict)：从字典对象导入数据，Key是列名，Value是数据
复制代码
 

导出数据：

df.to_csv(filename)：导出数据到CSV文件
df.to_excel(filename)：导出数据到Excel文件
df.to_sql(table_name, connection_object)：导出数据到SQL表
df.to_json(filename)：以Json格式导出数据到文本文件
 

创建测试对象：

pd.DataFrame(np.random.rand(20,5))：创建20行5列的随机数组成的DataFrame对象
pd.Series(my_list)：从可迭代对象my_list创建一个Series对象
df.index = pd.date_range('1900/1/30', periods=df.shape[0])：增加一个日期索引
 

查看、检查数据：

复制代码
df.head(n)：查看DataFrame对象的前n行
df.tail(n)：查看DataFrame对象的最后n行
df.shape()：查看行数和列数
http:// df.info() ：查看索引、数据类型和内存信息
df.describe()：查看数值型列的汇总统计
s.value_counts(dropna=False)：查看Series对象的唯一值和计数
df.apply(pd.Series.value_counts)：查看DataFrame对象中每一列的唯一值和计数
复制代码
 

数据选取：

df[col]：根据列名，并以Series的形式返回列
df[[col1, col2]]：以DataFrame形式返回多列
s.iloc[0]：按位置选取数据
s.loc['index_one']：按索引选取数据
df.iloc[0,:]：返回第一行
df.iloc[0,0]：返回第一列的第一个元素
 

数据统计：

复制代码
df.describe()：查看数据值列的汇总统计
df.mean()：返回所有列的均值
df.corr()：返回列与列之间的相关系数
df.count()：返回每一列中的非空值的个数
df.max()：返回每一列的最大值
df.min()：返回每一列的最小值
df.median()：返回每一列的中位数
df.std()：返回每一列的标准差
复制代码
 

数据合并：

df1.append(df2)：将df2中的行添加到df1的尾部
df.concat([df1, df2],axis=1)：将df2中的列添加到df1的尾部
df1.join(df2,on=col1,how='inner')：对df1的列和df2的列执行SQL形式的join
 

数据处理：

复制代码
df[df[col] > 0.5]：选择col列的值大于0.5的行
df.sort_values(col1)：按照列col1排序数据，默认升序排列
df.sort_values(col2, ascending=False)：按照列col1降序排列数据
df.sort_values([col1,col2], ascending=[True,False])：先按列col1升序排列，后按col2降序排列数据
df.groupby(col)：返回一个按列col进行分组的Groupby对象
df.groupby([col1,col2])：返回一个按多列进行分组的Groupby对象
df.groupby(col1)[col2]：返回按列col1进行分组后，列col2的均值
df.pivot_table(index=col1, values=[col2,col3], aggfunc=max)：创建一个按列col1进行分组，并计算col2和col3的最大值的数据透视表
df.groupby(col1).agg(np.mean)：返回按列col1分组的所有列的均值
data.apply(np.mean)：对DataFrame中的每一列应用函数np.mean
data.apply(np.max,axis=1)：对DataFrame中的每一行应用函数np.max
复制代码
 

数据清理：

复制代码
df[df[col] > 0.5]：选择col列的值大于0.5的行
df.sort_values(col1)：按照列col1排序数据，默认升序排列
df.sort_values(col2, ascending=False)：按照列col1降序排列数据
df.sort_values([col1,col2], ascending=[True,False])：先按列col1升序排列，后按col2降序排列数据
df.groupby(col)：返回一个按列col进行分组的Groupby对象
df.groupby([col1,col2])：返回一个按多列进行分组的Groupby对象
df.groupby(col1)[col2]：返回按列col1进行分组后，列col2的均值
df.pivot_table(index=col1, values=[col2,col3], aggfunc=max)：创建一个按列col1进行分组，并计算col2和col3的最大值的数据透视表
df.groupby(col1).agg(np.mean)：返回按列col1分组的所有列的均值
data.apply(np.mean)：对DataFrame中的每一列应用函数np.mean
data.apply(np.max,axis=1)：对DataFrame中的每一行应用函数np.max
复制代码
 

其它操作：

改列名：

 

方法1
a.columns = ['a','b','c']

方法2
a.rename(columns={'A':'a', 'B':'b', 'C':'c'}, inplace = True)
 

 

 插入行列

http://www.jianshu.com/p/7df2593a01ce

 

 

相关参考链接：

复制代码
参考
http://www.qingpingshan.com/rjbc/dashuju/228593.html

十分钟搞定
http://python.jobbole.com/84416/

官方文档
http://pandas.pydata.org/pandas-docs/stable/index.html

操作索引
https://www.dataquest.io/blog/images/cheat-sheets/pandas-cheat-sheet.pdf
复制代码
 

 

进阶



取数（元素）：

复制代码
取df中某一个具体的数据
iloc     index locate 
举例 ：
    print df.iloc[0,0]
    print df.iloc[1, 1]
    print df.iloc[19, 7]

如果 df 是日期索引 +  a,b,c 列名

loc      locate

df.loc[ '2017-01-01', 'A'  ]
复制代码
 

取数（行）：

复制代码
    one_row = df.iloc[4]
    one_row2 = df.loc['2013-01-02']
    print type(one_row)


取某一行， 取出来后之后的数据类型是   Series
可以  one_row.iloc[1], 再访问 Series 里的数据

    print one_row.iloc[1]
    print one_row.loc['A']
复制代码
 

取数（列）：

 

复制代码
column2 = df['A']

column2 是一个 Series 类型

print type( column2 )

可访问 列里面的数据
    print column2[0]
    print column2['2013-01-03']
复制代码
 

取数（切片）：

复制代码
行模式切片

    dfsub1 = df.iloc[4:5]
    print type( dfsub1 )
    print  dfsub1

    dfsub2 = df.loc['2013-01-03':'2013-01-05']
    print  dfsub2

切片的结果 还是df,  而且改变 dfsub, 会同时改变
df


-------------------------------------------------
列模式 
    print ' get sub by  column mode '
    dfsub = df[['A','B']]
    print type( dfsub )
    print  dfsub


-------------------------------------------------
子集 
row  x  column
方式一：
    print ' get sub by  row  X column  mode '
    dfsub = df.loc['20130102':'20130104', ['A', 'B']]
    print type( dfsub )
    print  dfsub
方式二

dfsub = df.iloc[ 1:3, 1:3 ]
-------------------------------------------------
复制代码
 

取数（条件切片）：

复制代码
dfsub =  df[  (df.A > 0) and  (df.B > 0)  ]
结果类型是 df

这个玩意很想数据库里的    select where 

送一个特殊条件

print df[ df > 0 ]
复制代码
 

行遍历 ：

复制代码
def testForeach():

        df = pd.read_table('D:/run/data/sz002626_2017-01-04.cvs', encoding='gbk')  # ,header=0
        df = df.sort_index(axis=0, ascending=False)
        df.columns = [1, 2, 3, 4, 5, 6]
        df[7] = 'kong'
        print  df

        # 清洗
        df[3] = df[3].replace('--', '0.00')
        df[3] = df[3].astype(float)

        #遍历
        df[7] = df.apply(lambda r: dorec(r), axis=1)
        print df
        pass

def dorec(rec):
        if (rec[3] > 0):
            return '涨'
        if (rec[3] < 0):
            return '跌'
        else:
            return '平'
复制代码